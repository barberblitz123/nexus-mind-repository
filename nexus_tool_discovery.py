"""
NEXUS Tool Discovery System - Autonomous API/Tool Discovery and Integration
"""

import asyncio
import json
import logging
from typing import Dict, List, Any, Optional, Tuple, Callable
from datetime import datetime
from dataclasses import dataclass, asdict
from pathlib import Path
import aiohttp
import yaml
from abc import ABC, abstractmethod
import hashlib
import ast
import inspect
from urllib.parse import urlparse
import re

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@dataclass
class ToolSpecification:
    """Specification for a discovered tool"""
    id: str
    name: str
    type: str  # api, library, cli, service
    description: str
    endpoints: List[Dict[str, Any]]
    authentication: Dict[str, Any]
    rate_limits: Dict[str, Any]
    capabilities: List[str]
    documentation_url: str
    discovered_at: datetime
    quality_score: float = 0.0
    
@dataclass
class IntegrationTest:
    """Test results for tool integration"""
    tool_id: str
    test_type: str
    success: bool
    latency: float
    error_rate: float
    throughput: float
    reliability_score: float
    issues: List[str]
    recommendations: List[str]

@dataclass
class ToolRecommendation:
    """Tool recommendation for a specific task"""
    task_type: str
    recommended_tools: List[str]
    combination_strategy: str
    expected_performance: Dict[str, Any]
    fallback_options: List[str]
    confidence: float

class APIClientGenerator:
    """Generates Python clients for discovered APIs"""
    
    def __init__(self):
        self.templates = self._load_templates()
    
    def _load_templates(self) -> Dict[str, str]:
        """Load code generation templates"""
        return {
            "rest_client": self._rest_client_template(),
            "graphql_client": self._graphql_client_template(),
            "websocket_client": self._websocket_client_template()
        }
    
    def _rest_client_template(self) -> str:
        """REST API client template"""
        return '''"""
Auto-generated client for {api_name}
Generated by NEXUS Tool Discovery System
"""

import aiohttp
import asyncio
from typing import Dict, Any, Optional
import json

class {class_name}Client:
    """Client for {api_name} API"""
    
    def __init__(self, base_url: str = "{base_url}", api_key: Optional[str] = None):
        self.base_url = base_url.rstrip('/')
        self.api_key = api_key
        self.session = None
        
    async def __aenter__(self):
        self.session = aiohttp.ClientSession()
        return self
        
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if self.session:
            await self.session.close()
    
    def _get_headers(self) -> Dict[str, str]:
        headers = {{"Content-Type": "application/json"}}
        if self.api_key:
            headers["{auth_header}"] = f"{auth_prefix}{self.api_key}"
        return headers
    
{methods}
    
    async def _request(self, method: str, endpoint: str, **kwargs) -> Dict[str, Any]:
        """Make HTTP request"""
        url = f"{{self.base_url}}{{endpoint}}"
        headers = self._get_headers()
        
        async with self.session.request(method, url, headers=headers, **kwargs) as response:
            response.raise_for_status()
            return await response.json()

# Example usage
async def main():
    async with {class_name}Client(api_key="your_api_key") as client:
        result = await client.{first_method}()
        print(result)

if __name__ == "__main__":
    asyncio.run(main())
'''
    
    def _graphql_client_template(self) -> str:
        """GraphQL client template"""
        return '''"""
Auto-generated GraphQL client for {api_name}
"""

import aiohttp
import asyncio
from typing import Dict, Any, Optional

class {class_name}GraphQLClient:
    """GraphQL client for {api_name}"""
    
    def __init__(self, endpoint: str = "{endpoint}", api_key: Optional[str] = None):
        self.endpoint = endpoint
        self.api_key = api_key
        
    async def query(self, query: str, variables: Optional[Dict] = None) -> Dict[str, Any]:
        """Execute GraphQL query"""
        headers = {{"Content-Type": "application/json"}}
        if self.api_key:
            headers["Authorization"] = f"Bearer {{self.api_key}}"
            
        payload = {{"query": query}}
        if variables:
            payload["variables"] = variables
            
        async with aiohttp.ClientSession() as session:
            async with session.post(self.endpoint, json=payload, headers=headers) as response:
                response.raise_for_status()
                return await response.json()
    
    async def mutation(self, mutation: str, variables: Optional[Dict] = None) -> Dict[str, Any]:
        """Execute GraphQL mutation"""
        return await self.query(mutation, variables)
'''
    
    def _websocket_client_template(self) -> str:
        """WebSocket client template"""
        return '''"""
Auto-generated WebSocket client for {api_name}
"""

import aiohttp
import asyncio
import json
from typing import Dict, Any, Optional, Callable

class {class_name}WebSocketClient:
    """WebSocket client for {api_name}"""
    
    def __init__(self, ws_url: str = "{ws_url}", api_key: Optional[str] = None):
        self.ws_url = ws_url
        self.api_key = api_key
        self.ws = None
        
    async def connect(self):
        """Connect to WebSocket"""
        session = aiohttp.ClientSession()
        headers = {{}}
        if self.api_key:
            headers["Authorization"] = f"Bearer {{self.api_key}}"
            
        self.ws = await session.ws_connect(self.ws_url, headers=headers)
        
    async def send(self, message: Dict[str, Any]):
        """Send message"""
        await self.ws.send_json(message)
        
    async def receive(self) -> Dict[str, Any]:
        """Receive message"""
        msg = await self.ws.receive()
        if msg.type == aiohttp.WSMsgType.TEXT:
            return json.loads(msg.data)
        return {{}}
        
    async def close(self):
        """Close connection"""
        if self.ws:
            await self.ws.close()
'''
    
    def generate_client(self, spec: ToolSpecification) -> Dict[str, str]:
        """Generate client code for API"""
        if spec.type == "graphql":
            template = self.templates["graphql_client"]
            code = template.format(
                api_name=spec.name,
                class_name=self._to_class_name(spec.name),
                endpoint=spec.endpoints[0]["url"] if spec.endpoints else ""
            )
        elif spec.type == "websocket":
            template = self.templates["websocket_client"]
            code = template.format(
                api_name=spec.name,
                class_name=self._to_class_name(spec.name),
                ws_url=spec.endpoints[0]["url"] if spec.endpoints else ""
            )
        else:  # REST API
            template = self.templates["rest_client"]
            methods = self._generate_methods(spec.endpoints)
            
            auth_header = "Authorization"
            auth_prefix = "Bearer "
            
            if spec.authentication.get("type") == "api_key":
                auth_header = spec.authentication.get("header", "X-API-Key")
                auth_prefix = spec.authentication.get("prefix", "")
            
            code = template.format(
                api_name=spec.name,
                class_name=self._to_class_name(spec.name),
                base_url=self._extract_base_url(spec.endpoints),
                auth_header=auth_header,
                auth_prefix=auth_prefix,
                methods=methods,
                first_method=self._extract_first_method(spec.endpoints)
            )
        
        return {
            "filename": f"{spec.name.lower()}_client.py",
            "code": code
        }
    
    def _to_class_name(self, name: str) -> str:
        """Convert to valid class name"""
        return ''.join(word.capitalize() for word in re.split(r'[-_\s]', name))
    
    def _extract_base_url(self, endpoints: List[Dict]) -> str:
        """Extract base URL from endpoints"""
        if not endpoints:
            return ""
        
        url = endpoints[0].get("url", "")
        parsed = urlparse(url)
        return f"{parsed.scheme}://{parsed.netloc}"
    
    def _generate_methods(self, endpoints: List[Dict]) -> str:
        """Generate methods for endpoints"""
        methods = []
        
        for endpoint in endpoints:
            method_name = self._endpoint_to_method_name(endpoint)
            http_method = endpoint.get("method", "GET").upper()
            path = endpoint.get("path", "/")
            params = endpoint.get("parameters", [])
            
            # Generate method signature
            param_args = []
            for param in params:
                param_name = param.get("name", "param")
                param_type = "Any"
                if param.get("required", False):
                    param_args.append(f"{param_name}: {param_type}")
                else:
                    param_args.append(f"{param_name}: Optional[{param_type}] = None")
            
            param_str = ", ".join(param_args)
            if param_str:
                param_str = ", " + param_str
            
            # Generate method body
            method_code = f'''
    async def {method_name}(self{param_str}) -> Dict[str, Any]:
        """{endpoint.get('description', 'API endpoint')}"""
        endpoint = "{path}"
        '''
            
            if http_method in ["POST", "PUT", "PATCH"]:
                method_code += f'''
        data = {{}}
        {self._generate_param_assignment(params)}
        return await self._request("{http_method}", endpoint, json=data)'''
            else:
                method_code += f'''
        params = {{}}
        {self._generate_param_assignment(params, is_query=True)}
        return await self._request("{http_method}", endpoint, params=params)'''
            
            methods.append(method_code)
        
        return "\n".join(methods)
    
    def _endpoint_to_method_name(self, endpoint: Dict) -> str:
        """Convert endpoint to method name"""
        path = endpoint.get("path", "")
        method = endpoint.get("method", "get").lower()
        
        # Clean path
        path_parts = [p for p in path.split('/') if p and not p.startswith('{')]
        
        if not path_parts:
            return f"{method}_root"
        
        return f"{method}_{'_'.join(path_parts)}"
    
    def _extract_first_method(self, endpoints: List[Dict]) -> str:
        """Extract first method name"""
        if not endpoints:
            return "get_root"
        return self._endpoint_to_method_name(endpoints[0])
    
    def _generate_param_assignment(self, params: List[Dict], is_query: bool = False) -> str:
        """Generate parameter assignment code"""
        assignments = []
        param_dict = "params" if is_query else "data"
        
        for param in params:
            param_name = param.get("name", "param")
            assignments.append(f'''
        if {param_name} is not None:
            {param_dict}["{param_name}"] = {param_name}''')
        
        return "".join(assignments)

class ToolSandbox:
    """Safe sandbox for testing tool integrations"""
    
    def __init__(self, timeout: int = 30, max_memory: int = 100):
        self.timeout = timeout
        self.max_memory = max_memory
        self.test_results: List[IntegrationTest] = []
    
    async def test_tool(self, spec: ToolSpecification, test_data: Dict[str, Any]) -> IntegrationTest:
        """Test tool in sandbox environment"""
        logger.info(f"Testing tool: {spec.name}")
        
        # Simulate sandbox testing
        start_time = datetime.now()
        
        try:
            # Test basic connectivity
            success = await self._test_connectivity(spec)
            
            # Test performance
            latency = await self._test_latency(spec)
            throughput = await self._test_throughput(spec)
            
            # Calculate scores
            error_rate = 0.01 if success else 0.5
            reliability_score = 0.99 if success else 0.5
            
            issues = []
            if latency > 1000:  # 1 second
                issues.append("High latency detected")
            if throughput < 100:  # requests per second
                issues.append("Low throughput")
            
            recommendations = []
            if issues:
                recommendations.append("Consider caching responses")
                recommendations.append("Implement connection pooling")
            
            test = IntegrationTest(
                tool_id=spec.id,
                test_type="comprehensive",
                success=success,
                latency=latency,
                error_rate=error_rate,
                throughput=throughput,
                reliability_score=reliability_score,
                issues=issues,
                recommendations=recommendations
            )
            
        except Exception as e:
            logger.error(f"Test failed: {e}")
            test = IntegrationTest(
                tool_id=spec.id,
                test_type="comprehensive",
                success=False,
                latency=0,
                error_rate=1.0,
                throughput=0,
                reliability_score=0,
                issues=[str(e)],
                recommendations=["Fix connection issues"]
            )
        
        self.test_results.append(test)
        return test
    
    async def _test_connectivity(self, spec: ToolSpecification) -> bool:
        """Test basic connectivity"""
        # Simulate connectivity test
        await asyncio.sleep(0.1)
        return True  # Simulated success
    
    async def _test_latency(self, spec: ToolSpecification) -> float:
        """Test average latency"""
        # Simulate latency test
        await asyncio.sleep(0.05)
        return 150.0  # milliseconds
    
    async def _test_throughput(self, spec: ToolSpecification) -> float:
        """Test throughput"""
        # Simulate throughput test
        await asyncio.sleep(0.05)
        return 500.0  # requests per second

class NexusToolDiscovery:
    """Main tool discovery and integration system"""
    
    def __init__(self, workspace_path: str = "./nexus_tools"):
        self.workspace = Path(workspace_path)
        self.workspace.mkdir(exist_ok=True)
        
        # Tool registry
        self.discovered_tools: Dict[str, ToolSpecification] = {}
        self.tool_clients: Dict[str, str] = {}  # Generated client code
        self.integration_tests: Dict[str, IntegrationTest] = {}
        self.tool_combinations: List[Dict[str, Any]] = []
        
        # Components
        self.client_generator = APIClientGenerator()
        self.sandbox = ToolSandbox()
        
        # Quality thresholds
        self.quality_threshold = 0.7
        self.reliability_threshold = 0.8
        
        # Initialize tool database
        self._init_tool_db()
    
    def _init_tool_db(self):
        """Initialize tool database"""
        self.db_path = self.workspace / "tool_registry.json"
        if self.db_path.exists():
            with open(self.db_path, 'r') as f:
                data = json.load(f)
                for tool_data in data.get("tools", []):
                    tool = ToolSpecification(**tool_data)
                    self.discovered_tools[tool.id] = tool
    
    async def search_for_tools(self, challenge: Dict[str, Any]) -> List[ToolSpecification]:
        """Search for tools to solve a specific challenge"""
        logger.info(f"Searching for tools to solve: {challenge.get('type')}")
        
        discovered = []
        
        # Define search strategies based on challenge type
        if challenge.get("type") == "data_processing":
            # Search for data processing tools
            tools = await self._search_data_tools()
            discovered.extend(tools)
        
        elif challenge.get("type") == "machine_learning":
            # Search for ML tools
            tools = await self._search_ml_tools()
            discovered.extend(tools)
        
        elif challenge.get("type") == "communication":
            # Search for communication APIs
            tools = await self._search_communication_tools()
            discovered.extend(tools)
        
        else:
            # Generic search
            tools = await self._generic_tool_search(challenge)
            discovered.extend(tools)
        
        # Register discovered tools
        for tool in discovered:
            self.discovered_tools[tool.id] = tool
        
        logger.info(f"Discovered {len(discovered)} tools")
        return discovered
    
    async def _search_data_tools(self) -> List[ToolSpecification]:
        """Search for data processing tools"""
        # Simulate tool discovery
        tools = []
        
        # Example: Discover a data transformation API
        tool = ToolSpecification(
            id=hashlib.md5("data_transform_api".encode()).hexdigest()[:8],
            name="DataTransformAPI",
            type="api",
            description="RESTful API for data transformation and processing",
            endpoints=[
                {
                    "method": "POST",
                    "path": "/transform",
                    "description": "Transform data between formats",
                    "parameters": [
                        {"name": "input_format", "type": "string", "required": True},
                        {"name": "output_format", "type": "string", "required": True},
                        {"name": "data", "type": "object", "required": True}
                    ]
                },
                {
                    "method": "GET",
                    "path": "/formats",
                    "description": "Get supported formats"
                }
            ],
            authentication={"type": "api_key", "header": "X-API-Key"},
            rate_limits={"requests_per_minute": 100},
            capabilities=["json_transform", "csv_processing", "xml_parsing"],
            documentation_url="https://api.datatransform.example/docs",
            discovered_at=datetime.now()
        )
        tools.append(tool)
        
        return tools
    
    async def _search_ml_tools(self) -> List[ToolSpecification]:
        """Search for machine learning tools"""
        tools = []
        
        # Example: Discover ML inference API
        tool = ToolSpecification(
            id=hashlib.md5("ml_inference_api".encode()).hexdigest()[:8],
            name="MLInferenceAPI",
            type="api",
            description="Machine learning model inference service",
            endpoints=[
                {
                    "method": "POST",
                    "path": "/predict",
                    "description": "Make predictions",
                    "parameters": [
                        {"name": "model_id", "type": "string", "required": True},
                        {"name": "input_data", "type": "array", "required": True}
                    ]
                },
                {
                    "method": "GET",
                    "path": "/models",
                    "description": "List available models"
                }
            ],
            authentication={"type": "bearer", "header": "Authorization"},
            rate_limits={"requests_per_second": 10},
            capabilities=["classification", "regression", "clustering"],
            documentation_url="https://ml.inference.example/docs",
            discovered_at=datetime.now()
        )
        tools.append(tool)
        
        return tools
    
    async def _search_communication_tools(self) -> List[ToolSpecification]:
        """Search for communication tools"""
        tools = []
        
        # Example: Discover messaging API
        tool = ToolSpecification(
            id=hashlib.md5("messaging_api".encode()).hexdigest()[:8],
            name="MessagingAPI",
            type="api",
            description="Real-time messaging and notification service",
            endpoints=[
                {
                    "method": "POST",
                    "path": "/messages/send",
                    "description": "Send message",
                    "parameters": [
                        {"name": "recipient", "type": "string", "required": True},
                        {"name": "message", "type": "string", "required": True},
                        {"name": "channel", "type": "string", "required": False}
                    ]
                }
            ],
            authentication={"type": "api_key", "header": "X-API-Key"},
            rate_limits={"messages_per_minute": 60},
            capabilities=["sms", "email", "push_notifications"],
            documentation_url="https://messaging.example/docs",
            discovered_at=datetime.now()
        )
        tools.append(tool)
        
        return tools
    
    async def _generic_tool_search(self, challenge: Dict[str, Any]) -> List[ToolSpecification]:
        """Generic tool search based on keywords"""
        # Implement keyword-based search
        keywords = challenge.get("keywords", [])
        
        # Simulate search results
        tools = []
        
        if "database" in keywords:
            tool = ToolSpecification(
                id=hashlib.md5("database_tool".encode()).hexdigest()[:8],
                name="DatabaseConnector",
                type="library",
                description="Universal database connector",
                endpoints=[],
                authentication={},
                rate_limits={},
                capabilities=["sql", "nosql", "timeseries"],
                documentation_url="https://dbconnector.example/docs",
                discovered_at=datetime.now()
            )
            tools.append(tool)
        
        return tools
    
    async def generate_client(self, tool_id: str) -> Dict[str, str]:
        """Generate client code for a tool"""
        tool = self.discovered_tools.get(tool_id)
        
        if not tool:
            raise ValueError(f"Tool not found: {tool_id}")
        
        # Generate client code
        client_info = self.client_generator.generate_client(tool)
        
        # Save generated code
        client_path = self.workspace / "clients" / client_info["filename"]
        client_path.parent.mkdir(exist_ok=True)
        
        with open(client_path, 'w') as f:
            f.write(client_info["code"])
        
        self.tool_clients[tool_id] = str(client_path)
        
        logger.info(f"Generated client for {tool.name}: {client_path}")
        return client_info
    
    async def test_integration(self, tool_id: str) -> IntegrationTest:
        """Test tool integration in sandbox"""
        tool = self.discovered_tools.get(tool_id)
        
        if not tool:
            raise ValueError(f"Tool not found: {tool_id}")
        
        # Prepare test data
        test_data = {
            "endpoints": tool.endpoints[:2],  # Test first 2 endpoints
            "auth": tool.authentication
        }
        
        # Run sandbox test
        test_result = await self.sandbox.test_tool(tool, test_data)
        
        # Store result
        self.integration_tests[tool_id] = test_result
        
        # Update tool quality score
        tool.quality_score = self._calculate_quality_score(test_result)
        
        return test_result
    
    def _calculate_quality_score(self, test: IntegrationTest) -> float:
        """Calculate tool quality score"""
        score = 0.0
        
        # Success rate (40%)
        score += 0.4 if test.success else 0.0
        
        # Latency score (20%)
        if test.latency < 100:
            score += 0.2
        elif test.latency < 500:
            score += 0.1
        
        # Reliability (20%)
        score += 0.2 * test.reliability_score
        
        # Error rate (20%)
        score += 0.2 * (1 - test.error_rate)
        
        return min(score, 1.0)
    
    async def map_capabilities(self) -> Dict[str, List[str]]:
        """Map all discovered tool capabilities"""
        capability_map = {}
        
        for tool in self.discovered_tools.values():
            for capability in tool.capabilities:
                if capability not in capability_map:
                    capability_map[capability] = []
                capability_map[capability].append(tool.id)
        
        logger.info(f"Mapped {len(capability_map)} capabilities")
        return capability_map
    
    async def recommend_tools(self, task: Dict[str, Any]) -> ToolRecommendation:
        """Recommend tools for a specific task"""
        task_type = task.get("type", "general")
        requirements = task.get("requirements", [])
        
        # Get capability map
        capability_map = await self.map_capabilities()
        
        # Find tools matching requirements
        matching_tools = set()
        for req in requirements:
            if req in capability_map:
                matching_tools.update(capability_map[req])
        
        # Filter by quality
        recommended = []
        for tool_id in matching_tools:
            tool = self.discovered_tools.get(tool_id)
            if tool and tool.quality_score >= self.quality_threshold:
                recommended.append(tool_id)
        
        # Determine combination strategy
        if len(recommended) > 1:
            combination_strategy = "pipeline"  # Chain tools together
        else:
            combination_strategy = "single"
        
        # Identify fallbacks
        fallbacks = []
        for tool_id in matching_tools:
            if tool_id not in recommended:
                fallbacks.append(tool_id)
        
        recommendation = ToolRecommendation(
            task_type=task_type,
            recommended_tools=recommended[:3],  # Top 3
            combination_strategy=combination_strategy,
            expected_performance={
                "success_rate": 0.95,
                "latency": "200ms",
                "throughput": "1000 req/s"
            },
            fallback_options=fallbacks[:2],
            confidence=0.85 if recommended else 0.3
        )
        
        logger.info(f"Recommended {len(recommended)} tools for {task_type}")
        return recommendation
    
    async def create_tool_combination(self, tools: List[str], strategy: str) -> Dict[str, Any]:
        """Create a combination of tools"""
        combination = {
            "id": hashlib.md5(f"{'_'.join(tools)}_{strategy}".encode()).hexdigest()[:8],
            "tools": tools,
            "strategy": strategy,
            "created_at": datetime.now()
        }
        
        if strategy == "pipeline":
            # Create pipeline configuration
            combination["pipeline"] = self._create_pipeline(tools)
        elif strategy == "parallel":
            # Create parallel configuration
            combination["parallel"] = self._create_parallel_config(tools)
        elif strategy == "fallback":
            # Create fallback chain
            combination["fallback_chain"] = tools
        
        self.tool_combinations.append(combination)
        logger.info(f"Created tool combination: {combination['id']}")
        
        return combination
    
    def _create_pipeline(self, tools: List[str]) -> List[Dict[str, Any]]:
        """Create pipeline configuration"""
        pipeline = []
        
        for i, tool_id in enumerate(tools):
            tool = self.discovered_tools.get(tool_id)
            if tool:
                stage = {
                    "stage": i + 1,
                    "tool_id": tool_id,
                    "tool_name": tool.name,
                    "input": "previous_output" if i > 0 else "user_input",
                    "output": f"stage_{i + 1}_output",
                    "error_handling": "continue_with_default"
                }
                pipeline.append(stage)
        
        return pipeline
    
    def _create_parallel_config(self, tools: List[str]) -> Dict[str, Any]:
        """Create parallel execution configuration"""
        return {
            "execution": "parallel",
            "tools": tools,
            "aggregation": "merge_results",
            "timeout": 30
        }
    
    async def handle_unreliable_tool(self, tool_id: str, error: Exception) -> Dict[str, Any]:
        """Handle unreliable tool with fallback strategies"""
        tool = self.discovered_tools.get(tool_id)
        
        if not tool:
            return {"status": "error", "message": "Tool not found"}
        
        # Update reliability score
        if tool_id in self.integration_tests:
            test = self.integration_tests[tool_id]
            test.reliability_score *= 0.9  # Decrease reliability
            test.issues.append(f"Error: {str(error)}")
        
        # Find alternatives
        alternatives = []
        for capability in tool.capabilities:
            # Find other tools with same capability
            for other_id, other_tool in self.discovered_tools.items():
                if other_id != tool_id and capability in other_tool.capabilities:
                    if other_tool.quality_score >= self.quality_threshold:
                        alternatives.append(other_id)
        
        # Create fallback strategy
        fallback_strategy = {
            "original_tool": tool_id,
            "error": str(error),
            "alternatives": alternatives[:3],
            "recommendations": [
                "Use alternative tool",
                "Implement retry with exponential backoff",
                "Cache successful responses"
            ]
        }
        
        logger.warning(f"Tool {tool.name} unreliable, found {len(alternatives)} alternatives")
        return fallback_strategy
    
    def save_discoveries(self):
        """Save discovered tools to database"""
        data = {
            "tools": [asdict(tool) for tool in self.discovered_tools.values()],
            "combinations": self.tool_combinations,
            "last_updated": datetime.now().isoformat()
        }
        
        with open(self.db_path, 'w') as f:
            json.dump(data, f, indent=2, default=str)
    
    def get_discovery_summary(self) -> Dict[str, Any]:
        """Get summary of discovered tools"""
        high_quality_tools = [
            tool for tool in self.discovered_tools.values()
            if tool.quality_score >= self.quality_threshold
        ]
        
        capability_count = len(set(
            cap for tool in self.discovered_tools.values()
            for cap in tool.capabilities
        ))
        
        return {
            "total_discovered": len(self.discovered_tools),
            "high_quality_tools": len(high_quality_tools),
            "unique_capabilities": capability_count,
            "generated_clients": len(self.tool_clients),
            "tested_integrations": len(self.integration_tests),
            "tool_combinations": len(self.tool_combinations)
        }

# Example usage
async def main():
    discovery = NexusToolDiscovery()
    
    # Search for tools
    challenge = {
        "type": "data_processing",
        "requirements": ["json_transform", "csv_processing"],
        "keywords": ["transform", "convert", "process"]
    }
    
    tools = await discovery.search_for_tools(challenge)
    print(f"Found {len(tools)} tools")
    
    # Generate client for first tool
    if tools:
        client = await discovery.generate_client(tools[0].id)
        print(f"Generated client: {client['filename']}")
        
        # Test integration
        test = await discovery.test_integration(tools[0].id)
        print(f"Integration test: Success={test.success}, Score={tools[0].quality_score}")
    
    # Get recommendations
    task = {
        "type": "data_transformation",
        "requirements": ["json_transform", "csv_processing"]
    }
    
    recommendation = await discovery.recommend_tools(task)
    print(f"Recommended tools: {recommendation.recommended_tools}")
    
    # Save discoveries
    discovery.save_discoveries()
    
    # Get summary
    summary = discovery.get_discovery_summary()
    print(f"Discovery summary: {summary}")

if __name__ == "__main__":
    asyncio.run(main())